<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photometric Studio (High Detail)</title>
    <script src="https://cdn.jsdelivr.net/npm/utif@3.0.0/UTIF.js"></script>

    <style>
        :root { --bg: #111; --panel: #1e1e1e; --accent: #4af; --text: #eee; }
        body { margin: 0; overflow: hidden; background-color: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; }
        
        #ui-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; }
        #sidebar { 
            width: 300px; background: rgba(30,30,30,0.9); backdrop-filter: blur(10px); 
            padding: 20px; border-right: 1px solid #333; pointer-events: auto; 
            display: flex; flex-direction: column; gap: 15px; overflow-y: auto;
        }
        
        h1 { margin: 0 0 10px 0; font-size: 1.1rem; color: var(--accent); }
        .instructions { font-size: 0.8rem; color: #888; margin-bottom: 10px; line-height: 1.4em; }

        .drop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        .drop-zone { 
            border: 2px dashed #444; border-radius: 6px; height: 80px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            position: relative; background: #222; transition: 0.2s;
        }
        .drop-zone:hover { border-color: var(--accent); background: #2a2a2a; }
        .drop-zone.filled { border-style: solid; border-color: #4caf50; }
        .drop-zone input { position: absolute; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        .dz-label { font-size: 0.75rem; font-weight: bold; pointer-events: none; }
        .thumb { width: 100%; height: 100%; object-fit: cover; display: none; position: absolute; border-radius: 4px; pointer-events: none; }

        button { 
            background: #333; color: white; border: 1px solid #555; padding: 10px; 
            border-radius: 4px; cursor: pointer; font-weight: bold; transition: 0.2s; 
        }
        button:hover { background: #444; border-color: #777; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .primary { background: var(--accent); border-color: var(--accent); color: #000; margin-top: auto; }
        .primary:hover { filter: brightness(1.1); }

        #drag-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(68, 170, 255, 0.2); border: 4px dashed var(--accent); 
            z-index: 999; display: none; pointer-events: none; 
            align-items: center; justify-content: center;
        }
        #drag-overlay.active { display: flex; }
        .drag-msg { font-size: 2rem; font-weight: bold; color: var(--accent); background: rgba(0,0,0,0.8); padding: 20px 40px; border-radius: 8px; }

        #loader { 
            position: absolute; top:0; left:0; width:100%; height:100%; 
            background: rgba(0,0,0,0.9); z-index: 1000; display: none; 
            align-items: center; justify-content: center; color: var(--accent); font-family: monospace;
        }
        
        #status-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 20px;
            pointer-events: none; color: #aaa; font-size: 0.85rem; transition: 0.3s; opacity: 0.7;
        }
        #status-indicator.frozen { color: #ffaa00; border: 1px solid #ffaa00; opacity: 1; }
    </style>
</head>
<body>

    <div id="drag-overlay"><div class="drag-msg">DROP IMAGES</div></div>
    <div id="loader">Processing...</div>
    <div id="status-indicator">Move mouse to rotate light. Click to freeze.</div>

    <div id="ui-container">
        <div id="sidebar">
            <h1>Photometric Studio</h1>
            <div>
              A proof of concept of a client-side only exploration experience
              for images taken by the Selene System which uses photometric
              stereo to simulate depth from four images with different lighting
              directions.
            </div>
            <div class="instructions">
                <strong>Controls:</strong><br>
                • Drag N/S/E/W images here<br>
                • Left Click + Drag to Pan<br>
                • Scroll to Zoom<br>
                • Click once to Freeze Light
            </div>
            
            <div class="drop-grid">
                <div class="drop-zone" id="dz-0">
                    <span class="dz-label">NORTH (1)</span>
                    <img id="thumb-0" class="thumb">
                    <input type="file" data-idx="0">
                </div>
                <div class="drop-zone" id="dz-1">
                    <span class="dz-label">SOUTH (3)</span>
                    <img id="thumb-1" class="thumb">
                    <input type="file" data-idx="1">
                </div>
                <div class="drop-zone" id="dz-2">
                    <span class="dz-label">EAST (2)</span>
                    <img id="thumb-2" class="thumb">
                    <input type="file" data-idx="2">
                </div>
                <div class="drop-zone" id="dz-3">
                    <span class="dz-label">WEST (4)</span>
                    <img id="thumb-3" class="thumb">
                    <input type="file" data-idx="3">
                </div>
            </div>

            <button class="primary" id="btn-gen" disabled>Generate Maps</button>

            <div style="display: flex; gap: 8px; margin-top: 15px;">
                <button id="btn-rotate" style="flex:1;">Rotate 90°</button>
                <button id="btn-toggle-color" style="flex:1;" disabled>Toggle Color</button>
            </div>

            <div style="display: flex; gap: 8px; margin-top: 8px;">
                <button id="btn-save-norm" style="flex:1;" disabled>Save Normal</button>
                <button id="btn-save-alb" style="flex:1;" disabled>Save Albedo</button>
            </div>
            <button id="btn-save-rough" style="margin-top: 8px;" disabled>Save Roughness</button>

            <button id="btn-snapshot" style="margin-top: 8px;" disabled>Take Snapshot</button>
        </div>
    </div>

<script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { OrbitControls } from 'https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { GUI } from 'https://esm.sh/lil-gui@0.19.1'; 

    const MAX_TEXTURE_SIZE = 4096;
    const inputs = [null, null, null, null]; 
    let renderer, scene, camera, controls, planeMesh;
    let pointLight, ambientLight;
    let generatedNormalMap, generatedAlbedoMap, generatedAlbedoMapGray, generatedRoughnessMap;
    let contentAspect = 1.0;
    let isLightFrozen = false;
    let isColor = true;
    let dragStartPos = { x: 0, y: 0 };
    
    // ThreeJS setup.
    scene = new THREE.Scene();
    scene.background = new THREE.Color('#111');

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 2);

    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); 
    renderer.outputColorSpace = THREE.LinearSRGBColorSpace; 
    document.body.appendChild(renderer.domElement);

    // Allow zoom/pan.
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableRotate = false; 
    controls.enableZoom = true;
    controls.enablePan = true;
    controls.mouseButtons = { LEFT: THREE.MOUSE.PAN, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };

    // The math only works for matte items, so make normal simulation matte.
    const material = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 1.0,
        metalness: 0.0,
        // Make normal scale 2 to start, just to dramaticize the depth for
        // better shadows.
        normalScale: new THREE.Vector2(2, 2)
    });
    
    const geometry = new THREE.PlaneGeometry(1, 1);
    planeMesh = new THREE.Mesh(geometry, material);
    scene.add(planeMesh);

    // Small ambient light
    ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    // Moving mouse around should make a point light that can be frozen.
    pointLight = new THREE.PointLight(0xfff0dd, 3.0); 
    pointLight.decay = 0; 
    pointLight.position.set(-1.5, 1.5, 0.5);
    scene.add(pointLight);

    // Sliders. Use lil-gui, thanks three.js.
    const gui = new GUI({ title: 'Studio Settings' });
    const params = {
        roughness: 1.0,
        normalScale: 2.0,
        lightIntensity: 3.0,
        lightZ: 0.5
    };

    gui.add(params, 'roughness', 0, 1).onChange(v => material.roughness = v);
    gui.add(params, 'normalScale', 0, 5).name('Relief Depth').onChange(v => material.normalScale.set(v, v));
    const folderLight = gui.addFolder('Raking Light');
    folderLight.add(params, 'lightIntensity', 0, 5).onChange(v => pointLight.intensity = v);
    folderLight.add(params, 'lightZ', 0.05, 2.0).name('Light Height').onChange(v => {
        pointLight.position.z = v;
    });

    // Only freeze the light if we're not panning.
    renderer.domElement.addEventListener('mousedown', e => { dragStartPos.x = e.clientX; dragStartPos.y = e.clientY; });
    renderer.domElement.addEventListener('click', e => {
        const dist = Math.hypot(e.clientX - dragStartPos.x, e.clientY - dragStartPos.y);
        if (dist < 5) { isLightFrozen = !isLightFrozen; updateStatus(); }
    });

    // Add rotate by 90, our cuneiforms were sideways.
    document.getElementById('btn-rotate').addEventListener('click', () => {
        planeMesh.rotation.z -= Math.PI / 2;
    });

    // A grayscale representation looks kinda like a height map which is cool.
    document.getElementById('btn-toggle-color').addEventListener('click', () => {
        if (!generatedAlbedoMap || !generatedAlbedoMapGray) return;
        isColor = !isColor;
        material.map = isColor ? generatedAlbedoMap : generatedAlbedoMapGray;
        material.needsUpdate = true;
    });

    // Render a scene to an image!
    document.getElementById('btn-snapshot').addEventListener('click', () => {
        renderer.render(scene, camera);
        const data = renderer.domElement.toDataURL("image/png");
        const a = document.createElement('a');
        a.href = data;
        a.download = 'snapshot.png';
        a.click();
    });

    // Move the point light when you move the mouse.
    window.addEventListener('mousemove', (e) => {
        if (isLightFrozen || e.buttons > 0) return;
        const mx = (e.clientX / window.innerWidth) * 2 - 1;
        const my = -(e.clientY / window.innerHeight) * 2 + 1;
        const angle = Math.atan2(my, mx);
        const dist = camera.position.z;
        const vFov = camera.fov * Math.PI / 180;
        // yay geometry.
        const visibleHeight = 2 * Math.tan(vFov / 2) * dist;
        const visibleWidth = visibleHeight * (window.innerWidth / window.innerHeight);
        const radius = Math.min(visibleWidth, visibleHeight) * 0.6; 
        pointLight.position.x = Math.cos(angle) * radius + camera.position.x;
        pointLight.position.y = Math.sin(angle) * radius + camera.position.y;
        pointLight.position.z = params.lightZ;
    });

    function updateStatus() {
        const el = document.getElementById('status-indicator');
        if(isLightFrozen) { el.innerText = "Light Frozen. Click to unfreeze."; el.classList.add('frozen'); }
        else { el.innerText = "Move mouse to rotate light. Click to freeze."; el.classList.remove('frozen'); }
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();

    // Drag/Drop for the Selene source images.
    const overlay = document.getElementById('drag-overlay');
    window.addEventListener('dragenter', () => overlay.classList.add('active'));
    window.addEventListener('dragleave', (e) => { if (!e.relatedTarget) overlay.classList.remove('active'); });
    window.addEventListener('dragover', e => e.preventDefault());
    window.addEventListener('drop', (e) => {
        e.preventDefault(); overlay.classList.remove('active'); handleFiles(e.dataTransfer.files);
    });
    document.querySelectorAll('input[type=file]').forEach(inp => {
        inp.addEventListener('change', (e) => {
            if(e.target.files[0]) processFile(e.target.files[0], parseInt(e.target.dataset.idx));
        });
    });

    function handleFiles(files) {
        showLoader(true);
        const fileArr = Array.from(files);
        let processed = 0;
        fileArr.forEach(file => {
            const n = file.name.toLowerCase();
            let idx = -1;
            // Auto-detect 1.tif/2.tif/3.tif/4.tif and N/E/S/W.tif filenames.
            if (/^(1|n)(\W|$)/i.test(n)) idx = 0; else if (/^(3|s)(\W|$)/i.test(n)) idx = 1;
            else if (/^(2|e)(\W|$)/i.test(n)) idx = 2; else if (/^(4|w)(\W|$)/i.test(n)) idx = 3;
            if (idx !== -1) {
                processFile(file, idx, () => {
                    processed++; if(processed === fileArr.length) showLoader(false);
                });
            }
        });
        if(processed === 0) showLoader(false);
    }

    // Process files into WebGL by loading an off-screen canvas and putting the
    // file in there. Gives us access to toDataURL(), for thumbnails and
    // downloads and stuff.
    function processFile(file, idx, cb) {
        const reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = (e) => {
            const buf = e.target.result;
            // JS can't handle tiff by default, use UTIF.
            const isTiff = file.name.match(/\.tif/i); 
            if (isTiff) {
                try {
                    const ifds = UTIF.decode(buf); UTIF.decodeImage(buf, ifds[0]);
                    const rgba = UTIF.toRGBA8(ifds[0]);
                    createCanvas(rgba, ifds[0].width, ifds[0].height, idx);
                } catch(err) { console.error(err); alert("TIFF Error"); }
            } else {
                // Otherwise load the image by making an image tag and deleting
                // it after.
                const blob = new Blob([buf]); const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas');
                    scaleToCanvas(img, c); URL.revokeObjectURL(img.src);
                    finishLoading(c, idx);
                }; img.src = URL.createObjectURL(blob);
            }
            if(cb) cb();
        };
    }

    // If the image is too big it just takes too long to process, WebGL crashes.
    function scaleToCanvas(source, canvas) {
        let w = source.width, h = source.height;
        if(w > MAX_TEXTURE_SIZE || h > MAX_TEXTURE_SIZE) {
            const r = Math.min(MAX_TEXTURE_SIZE/w, MAX_TEXTURE_SIZE/h);
            w = Math.floor(w*r); h = Math.floor(h*r);
        }
        canvas.width = w; canvas.height = h;
        canvas.getContext('2d').drawImage(source, 0, 0, w, h);
    }

    function createCanvas(rgba, w, h, idx) {
        const c = document.createElement('canvas');
        const t = document.createElement('canvas'); t.width=w; t.height=h;
        const d = new ImageData(new Uint8ClampedArray(rgba), w, h);
        t.getContext('2d').putImageData(d, 0, 0);
        scaleToCanvas(t, c);
        finishLoading(c, idx);
    }

    // Generate a little thumbnail for each uploaded thing.
    function finishLoading(c, idx) {
        inputs[idx] = c;
        const thumb = document.getElementById(`thumb-${idx}`);
        thumb.src = c.toDataURL('image/jpeg', 0.2);
        thumb.style.display = 'block';
        document.getElementById(`dz-${idx}`).classList.add('filled');
        if(inputs.every(x => x)) document.getElementById('btn-gen').disabled = false;
    }

    // Generate normals
    document.getElementById('btn-gen').addEventListener('click', () => {
        showLoader(true); setTimeout(generateMaps, 50);
    });

    // The hard math bit
    function generateMaps() {
        // Make a ThreeJS texture for every tiff canvas.
        const tex = inputs.map(c => {
            const t = new THREE.CanvasTexture(c);
            t.colorSpace = THREE.LinearSRGBColorSpace;
            t.minFilter = THREE.LinearFilter;
            return t;
        });

        const width = inputs[0].width;
        const height = inputs[0].height;
        const bakeScene = new THREE.Scene();
        const bakeCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        // The mesh here is for the normal we're gonna generate.
        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
        bakeScene.add(quad);
        const renderTargetOpts = { type: THREE.FloatType, minFilter: THREE.LinearFilter, generateMipmaps: false };

        // Generate a normal map.
        quad.material = new THREE.ShaderMaterial({
            uniforms: { uN:{value:tex[0]}, uS:{value:tex[1]}, uE:{value:tex[2]}, uW:{value:tex[3]} },
            vertexShader: `varying vec2 vUv; void main() { vUv=uv; gl_Position=vec4(position,1.0); }`,
            // A fragment shader runs for every pixel in the image, but usig the
            // GPU.
            fragmentShader: `
                uniform sampler2D uN, uS, uE, uW;
                varying vec2 vUv;
                void main() {
                    // Make a vector that will divide all the rgb values by 3 to
                    // get average intensity. Use dot because GPUs are good at
                    // matrix math.
                    vec3 k = vec3(1.0 / 3.0);
                    float n = dot(texture2D(uN, vUv).rgb, k); 
                    float s = dot(texture2D(uS, vUv).rgb, k);
                    float e = dot(texture2D(uE, vUv).rgb, k); 
                    float w = dot(texture2D(uW, vUv).rgb, k);
                    // If bright in east, but dark in west, then surface normal
                    // is east.
                    // If bright in south (+), but dark in N (-), surface is
                    // south.
                    // NOTE: This math only works because our lights are at 45
                    // degrees w/ Selene. It's much more complex otherwise.
                    vec3 N = vec3(e-w, s-n, 1.0);
                    // Normalize vector to length 1, then scale it from -1 to 1
                    // (unit vector domain) to 0 to 1 (color domain)
                    gl_FragColor = vec4(normalize(N)*0.5+0.5, 1.0);
                }
            `
        });
        const rtNorm = new THREE.WebGLRenderTarget(width, height, renderTargetOpts);
        renderer.setRenderTarget(rtNorm);
        renderer.render(bakeScene, bakeCam);
        generatedNormalMap = rtNorm.texture;

        // Albedo Map - average color to even out shadows.
        quad.material = new THREE.ShaderMaterial({
            uniforms: { uN:{value:tex[0]}, uS:{value:tex[1]}, uE:{value:tex[2]}, uW:{value:tex[3]} },
            vertexShader: `varying vec2 vUv; void main() { vUv=uv; gl_Position=vec4(position,1.0); }`,
            fragmentShader: `
                uniform sampler2D uN, uS, uE, uW;
                varying vec2 vUv;
                void main() {
                    vec4 avg = (texture2D(uN, vUv) + texture2D(uS, vUv) + texture2D(uE, vUv) + texture2D(uW, vUv)) / 4.0;
                    gl_FragColor = vec4(avg.rgb, 1.0);
                }
            `
        });
        const rtAlb = new THREE.WebGLRenderTarget(width, height, renderTargetOpts);
        renderer.setRenderTarget(rtAlb);
        renderer.render(bakeScene, bakeCam);
        generatedAlbedoMap = rtAlb.texture;

        // Grayscale Albedo. Pregenerate it so toggle is quick.
        quad.material = new THREE.ShaderMaterial({
            uniforms: { uN:{value:tex[0]}, uS:{value:tex[1]}, uE:{value:tex[2]}, uW:{value:tex[3]} },
            vertexShader: `varying vec2 vUv; void main() { vUv=uv; gl_Position=vec4(position,1.0); }`,
            fragmentShader: `
                uniform sampler2D uN, uS, uE, uW;
                varying vec2 vUv;
                void main() {
                    // This is the "Luma" method, humans see RGB differently so
                    // multiply differently.
                    vec4 avg = (texture2D(uN, vUv) + texture2D(uS, vUv) + texture2D(uE, vUv) + texture2D(uW, vUv)) / 4.0;
                    float g = dot(avg.rgb, vec3(0.299, 0.587, 0.114));
                    gl_FragColor = vec4(vec3(g), 1.0);
                }
            `
        });
        const rtAlbGray = new THREE.WebGLRenderTarget(width, height, renderTargetOpts);
        renderer.setRenderTarget(rtAlbGray);
        renderer.render(bakeScene, bakeCam);
        generatedAlbedoMapGray = rtAlbGray.texture;

        // Roughness Map (trying this)
        quad.material = new THREE.ShaderMaterial({
            uniforms: { uN:{value:tex[0]}, uS:{value:tex[1]}, uE:{value:tex[2]}, uW:{value:tex[3]} },
            vertexShader: `varying vec2 vUv; void main() { vUv=uv; gl_Position=vec4(position,1.0); }`,
            fragmentShader: `
                uniform sampler2D uN, uS, uE, uW;
                varying vec2 vUv;
                void main() {
                    // Same as normal map, get everything to average intensity.
                    vec3 k = vec3(1.0 / 3.0);
                    float n = dot(texture2D(uN, vUv).rgb, k);
                    float s = dot(texture2D(uS, vUv).rgb, k);
                    float e = dot(texture2D(uE, vUv).rgb, k);
                    float w = dot(texture2D(uW, vUv).rgb, k);
                    
                    // Estimate how reflective a thing is by the difference
                    // between the average shiny and the maximum shiny.
                    // Specularity = Max Brightness - Average Brightness
                    float mean = (n + s + e + w) / 4.0;
                    float maxVal = max(n, max(s, max(e, w)));
                    
                    // Little multiplier to make it more dramatic.
                    float spec = (maxVal - mean) * 2.5; 
                    spec = clamp(spec, 0.0, 1.0);

                    // We have shininess, so flip it because this is a roughness
                    // map.
                    float roughness = 1.0 - spec;
                    gl_FragColor = vec4(vec3(roughness), 1.0);
                }
            `
        });
        const rtRough = new THREE.WebGLRenderTarget(width, height, renderTargetOpts);
        renderer.setRenderTarget(rtRough);
        renderer.render(bakeScene, bakeCam);
        generatedRoughnessMap = rtRough.texture;

        renderer.setRenderTarget(null);

        isColor = true;
        material.map = generatedAlbedoMap; 
        material.normalMap = generatedNormalMap;
        material.roughnessMap = generatedRoughnessMap;
        material.normalScale.set(2, 2);
        material.needsUpdate = true;

        const aspect = width / height;
        contentAspect = aspect;
        planeMesh.scale.set(aspect, 1, 1);
        autoFrameCamera();

        document.getElementById('btn-save-norm').disabled = false;
        document.getElementById('btn-save-alb').disabled = false;
        document.getElementById('btn-save-rough').disabled = false;
        document.getElementById('btn-toggle-color').disabled = false;
        document.getElementById('btn-snapshot').disabled = false;
        showLoader(false);
    }

    function autoFrameCamera() {
        const vFov = camera.fov * (Math.PI / 180);
        let dist = (1.0 / 2) / Math.tan(vFov / 2);
        const screenAspect = window.innerWidth / window.innerHeight;
        if (contentAspect > screenAspect) {
            dist = dist * (contentAspect / screenAspect);
        }
        camera.position.set(0, 0, dist * 1.1);
        controls.target.set(0,0,0);
        controls.update();
    }

    function showLoader(show) { document.getElementById('loader').style.display = show ? 'flex' : 'none'; }

    function saveTexture(texture, filename) {
        if(!texture) return;
        const w = texture.image.width; const h = texture.image.height;
        const prevRatio = renderer.getPixelRatio();
        renderer.setPixelRatio(1); renderer.setSize(w, h);
        const s = new THREE.Scene();
        const c = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        const m = new THREE.MeshBasicMaterial({ map: texture });
        m.map.colorSpace = THREE.LinearSRGBColorSpace; 
        s.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), m));
        renderer.render(s, c);
        const d = renderer.domElement.toDataURL("image/png");
        renderer.setPixelRatio(prevRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        const a = document.createElement('a'); a.href = d; a.download = filename; a.click();
    }

    document.getElementById('btn-save-norm').addEventListener('click', () => saveTexture(generatedNormalMap, 'normal_map.png'));
    document.getElementById('btn-save-alb').addEventListener('click', () => {
        const t = isColor ? generatedAlbedoMap : generatedAlbedoMapGray;
        t.colorSpace = THREE.SRGBColorSpace;
        saveTexture(t, 'albedo_map.png');
    });
    document.getElementById('btn-save-rough').addEventListener('click', () => {
        saveTexture(generatedRoughnessMap, 'roughness_map.png');
    });

</script>
</body>
</html>
